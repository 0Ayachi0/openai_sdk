// OpenAI SDK ä¸»ç¨‹åº - æ¼”ç¤ºæ‰€æœ‰åŠŸèƒ½
// å®ç°å›¾ç‰‡ä¸­è¦æ±‚çš„5ä¸ªcase

// å¯¼å…¥çœŸå®ç½‘ç»œå®ç°
// use real_network::{perform_real_http_request, new_real_http_client, real_http_post}

// ==================== ç½‘ç»œçŠ¶æ€æ£€æŸ¥ ====================
///|
pub async fn check_network_status() -> Unit {
  println("ğŸŒ æ£€æŸ¥ç½‘ç»œçŠ¶æ€...")
  // è¿›è¡Œä¸€æ¬¡è½»é‡çº§ GET æ¢é’ˆä»¥éªŒè¯å¤–ç½‘å¯è¾¾æ€§ï¼ˆæ— éœ€é‰´æƒï¼Œæ¥å—ä»»æ„çŠ¶æ€ç å³è§†ä¸ºå¯è¾¾ï¼‰
  let probe_url = "https://api.openai.com/v1/models"
  match perform_http_request("GET", probe_url, [], "", 8) {
    Ok(resp) => {
      let (code, _headers, _body) = resp
      println("âœ… ç½‘ç»œå¯è¾¾ (" + code.to_string() + ") -> " + probe_url)
    }
    Err(err) => {
      let (t, c, m) = err
      println(
        "âš ï¸ ç½‘ç»œæ¢é’ˆå¤±è´¥: [" + c.to_string() + "] " + t + " - " + m,
      )
    }
  }
  println("")
}

// ==================== ç¨‹åºå…¥å£ ====================

///|
async fn main {
  main_from_args()
}
// ==================== Case 1: åŸºç¡€å¯¹è¯ ====================

///|
pub async fn demo_basic_conversation() -> Unit {
  println("=== Case 1: åŸºç¡€å¯¹è¯ ===")

  // åˆ›å»ºå®¢æˆ·ç«¯ï¼ˆä» CLI è¯»å– --api-key/--key/-kï¼‰
  let args = @env.args()
  let api_key_opt = parse_api_key_from_args(args)
  let mut api_key = ""
  match api_key_opt {
    Some(k) => api_key = k
    None => {
      println("â— æœªæä¾› API Keyã€‚è¯·ä½¿ç”¨ --api-key/--key/-k ä¼ å…¥ã€‚")
      return
    }
  }
  let client = new_client(api_key)
  let client = apply_runtime_config(client, args)

  // å‘é€ç®€å•æ¶ˆæ¯
  let question = "Say this is a test"
  println("ğŸ§­ æé—®: " + question)
  let result = simple_chat(client, question)
  match result {
    Ok(response) => {
      println("âœ… å¯¹è¯æˆåŠŸ:")
      println(response)
    }
    Err(error) => {
      println("âŒ å¯¹è¯å¤±è´¥:")
      println(error.0 + " - " + error.1)
      println(
        "   ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°ï¼Œå¤±è´¥å¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–APIå¯†é’¥é—®é¢˜",
      )
    }
  }
  println("")
}

// é€šè¿‡ CLI å‚æ•°é€‰æ‹©æ€§è¿è¡Œ Case 1ï¼šä¼ å…¥ --case=1 / --only=1 / --case1 ç­‰

///|
pub fn has_arg_case1(args : Array[String]) -> Bool {
  let mut i = 0
  while i < args.length() {
    let arg_opt = args.get(i)
    match arg_opt {
      None => {
        i = i + 1
        continue
      }
      Some(a) => {
        if a == "--case=1" ||
          a == "--case1" ||
          a == "--only=1" ||
          a == "--only=case1" ||
          a == "case1" {
          return true
        }
        if a == "--case" {
          let next_opt = args.get(i + 1)
          match next_opt {
            Some(n) => if n == "1" { return true }
            None => ()
          }
        }
      }
    }
    i = i + 1
  }
  false
}

// ä»å‘½ä»¤è¡Œå‚æ•°ä¸­è§£æ API Keyï¼Œæ”¯æŒä»¥ä¸‹å½¢å¼ï¼š
// --api-key=VALUE  | --api-key VALUE | --key=VALUE | --key VALUE | -k VALUE | -k=VALUE

///|
pub fn parse_api_key_from_args(args : Array[String]) -> String? {
  let mut i = 0
  while i < args.length() {
    let arg_opt = args.get(i)
    match arg_opt {
      None => {
        i = i + 1
        continue
      }
      Some(a) =>
        if a.has_prefix("--api-key=") {
          let value = string_substring_from(a, "--api-key=".length())
          if value.length() > 0 {
            return Some(value)
          }
        } else if a == "--api-key" {
          let next_opt = args.get(i + 1)
          match next_opt {
            Some(v) => if v.length() > 0 { return Some(v) }
            None => ()
          }
        } else if a.has_prefix("--key=") {
          let value = string_substring_from(a, "--key=".length())
          if value.length() > 0 {
            return Some(value)
          }
        } else if a == "--key" {
          let next_opt = args.get(i + 1)
          match next_opt {
            Some(v) => if v.length() > 0 { return Some(v) }
            None => ()
          }
        } else if a.has_prefix("-k=") {
          let value = string_substring_from(a, 3)
          if value.length() > 0 {
            return Some(value)
          }
        } else if a == "-k" {
          let next_opt = args.get(i + 1)
          match next_opt {
            Some(v) => if v.length() > 0 { return Some(v) }
            None => ()
          }
        } else {
          ()
        }
    }
    i = i + 1
  }
  None
}

// è§£æ Int å‚æ•°ï¼Œæ”¯æŒ --flag=VALUE ä¸ --flag VALUE ä¸¤ç§å½¢å¼

///|
pub fn parse_int_flag_from_args(args : Array[String], flag : String) -> Int? {
  let mut i = 0
  while i < args.length() {
    let arg_opt = args.get(i)
    match arg_opt {
      None => {
        i = i + 1
        continue
      }
      Some(a) => {
        let eq_form = "--" + flag + "="
        let sp_form = "--" + flag
        if a.has_prefix(eq_form) {
          let value_str = string_substring_from(a, eq_form.length())
          if value_str.length() > 0 {
            return Some(string_to_int(value_str))
          }
        } else if a == sp_form {
          let next_opt = args.get(i + 1)
          match next_opt {
            Some(v) => if v.length() > 0 { return Some(string_to_int(v)) }
            None => ()
          }
        } else {
          ()
        }
      }
    }
    i = i + 1
  }
  None
}

// è§£æå­—ç¬¦ä¸²å‚æ•°ï¼Œæ”¯æŒ --flag=VALUE ä¸ --flag VALUE ä¸¤ç§å½¢å¼

///|
pub fn parse_string_flag_from_args(
  args : Array[String],
  flag : String,
) -> String? {
  let mut i = 0
  while i < args.length() {
    let arg_opt = args.get(i)
    match arg_opt {
      None => {
        i = i + 1
        continue
      }
      Some(a) => {
        let eq_form = "--" + flag + "="
        let sp_form = "--" + flag
        if a.has_prefix(eq_form) {
          let value = string_substring_from(a, eq_form.length())
          if value.length() > 0 {
            return Some(value)
          }
        } else if a == sp_form {
          let next_opt = args.get(i + 1)
          match next_opt {
            Some(v) => if v.length() > 0 { return Some(v) }
            None => ()
          }
        } else {
          ()
        }
      }
    }
    i = i + 1
  }
  None
}

// æ ¹æ® CLI å‚æ•°åº”ç”¨è¿è¡Œæ—¶é…ç½®ï¼ˆè¶…æ—¶/é‡è¯•/åŸºç¡€URLï¼‰

///|
pub fn apply_runtime_config(
  client : OpenAIClient,
  args : Array[String],
) -> OpenAIClient {
  let (config, _hc) = client
  let (
    api_key,
    base_url,
    timeout,
    retries,
    user_agent,
    debug,
    _organization,
    _project,
  ) = config

  // è¯»å–å¯é€‰å‚æ•°
  let timeout_opt = parse_int_flag_from_args(args, "timeout") // ç§’
  let retries_opt = parse_int_flag_from_args(args, "retries")
  let base_url_opt = parse_string_flag_from_args(args, "base-url")

  // å…ˆåº”ç”¨åŸºç¡€URLï¼ˆå¦‚æä¾›ï¼‰
  let mut new_base_url = base_url
  match base_url_opt {
    Some(u) => new_base_url = u
    None => ()
  }

  // é‡å»ºå®¢æˆ·ç«¯ä»¥ç¡®ä¿ http_client åŒæ­¥æ›´æ–°
  let mut updated_client = new_client_with_config(
    api_key, new_base_url, timeout, retries, user_agent, debug,
  )

  // åº”ç”¨è¶…æ—¶
  match timeout_opt {
    Some(t) => updated_client = set_timeout(updated_client, t)
    None => ()
  }

  // åº”ç”¨é‡è¯•æ¬¡æ•°
  match retries_opt {
    Some(r) => updated_client = set_retries(updated_client, r)
    None => ()
  }
  updated_client
}

///|
pub async fn main_from_args() -> Unit {
  let args = @env.args()
  if has_arg_case1(args) {
    println("ğŸš€ OpenAI MoonBit SDK æ¼”ç¤ºç¨‹åº")
    println("ä»…è¿è¡Œ Case 1 è¿›è¡Œå¿«é€Ÿè¿é€šæ€§éªŒè¯")
    println("")

    // ç½‘ç»œçŠ¶æ€æ£€æŸ¥ä¸çœŸå®ç½‘ç»œæç¤º
    check_network_status()
    println("ğŸŒ ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°...")
    println("æ³¨æ„ï¼šç°åœ¨ä½¿ç”¨å®˜æ–¹asyncåº“è¿›è¡ŒçœŸå®ç½‘ç»œè¯·æ±‚")
    println("")
    demo_basic_conversation()
  } else {
    main_demo()
  }
}

// ==================== Case 2: æµå¼å“åº” ====================

///|
pub async fn demo_streaming_response() -> Unit {
  println("=== Case 2: æµå¼å“åº” ===")

  // åˆ›å»ºå®¢æˆ·ç«¯ï¼ˆä» CLI è¯»å– --api-key/--key/-kï¼‰
  let args = @env.args()
  let api_key_opt = parse_api_key_from_args(args)
  let mut api_key = ""
  match api_key_opt {
    Some(k) => api_key = k
    None => {
      println("â— æœªæä¾› API Keyã€‚è¯·ä½¿ç”¨ --api-key/--key/-k ä¼ å…¥ã€‚")
      return
    }
  }
  let client = new_client(api_key)
  let client = enable_debug(client)
  let client = apply_runtime_config(client, args)
  let question = "Tell me a story about a brave knight"
  println("ğŸ§­ æé—®: " + question)
  let result = stream_chat(client, question)
  match result {
    Ok(response) => {
      println("âœ… æµå¼å“åº”æˆåŠŸ:")
      println(response)
    }
    Err(error) => {
      println("âŒ æµå¼å“åº”å¤±è´¥:")
      println(error.0 + " - " + error.1)
      println(
        "   ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°ï¼Œå¤±è´¥å¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–APIå¯†é’¥é—®é¢˜",
      )
    }
  }
  println("")
}

// ==================== Case 3: å·¥å…·è°ƒç”¨ ====================

///|
pub async fn demo_tool_calling() -> Unit {
  println("=== Case 3: å·¥å…·è°ƒç”¨ ===")

  // åˆ›å»ºå®¢æˆ·ç«¯ï¼ˆä» CLI è¯»å– --api-key/--key/-kï¼‰
  let args = @env.args()
  let api_key_opt = parse_api_key_from_args(args)
  let mut api_key = ""
  match api_key_opt {
    Some(k) => api_key = k
    None => {
      println("â— æœªæä¾› API Keyã€‚è¯·ä½¿ç”¨ --api-key/--key/-k ä¼ å…¥ã€‚")
      return
    }
  }
  let client = new_client(api_key)
  let client = enable_debug(client)
  let client = apply_runtime_config(client, args)

  // å®šä¹‰å·¥å…·å‡½æ•°
  let tools = ["get_weather"]

  // ç¬¬1æ­¥ï¼šå‘æ¨¡å‹å‘èµ·å¸¦å·¥å…·çš„å¯¹è¯ï¼Œæ•è·å·¥å…·è°ƒç”¨
  let question = "What's the weather like in New York?"
  println("ğŸ§­ æé—®: " + question)
  let messages = [user_message(question)]
  let step1 = multi_turn_tool_chat(client, messages, tools)
  match step1 {
    Ok((assistant_msg, tool_call_opt, messages1)) =>
      match tool_call_opt {
        Some(tc) => {
          println("âœ… å·¥å…·è°ƒç”¨æˆåŠŸï¼ˆè¯·æ±‚å·¥å…·ï¼‰:")
          println(
            "å·¥å…·è°ƒç”¨: ID=" + tc.0 + ", ç±»å‹=" + tc.1 + ", å‡½æ•°=" + tc.2,
          )

          // è¿™é‡Œæ‰§è¡ŒçœŸå®å·¥å…·ï¼ˆget_weatherï¼‰ï¼Œä»é—®é¢˜ä¸­å°½åŠ›æŠ½å– location
          let inferred_location = extract_location_from_question(question).unwrap_or(
            "New York",
          )
          let tool_result = fetch_weather_for_location(
            client, inferred_location,
          )
          match tool_result {
            Ok(real_weather) => {
              println("ğŸ”§ å·¥å…·ç»“æœ: " + real_weather)
              let final_resp = handle_tool_result(
                client, messages1, tc, real_weather,
              )
              match final_resp {
                Ok(final_text) =>
                  println("ğŸ’¬ åŠ©æ‰‹æœ€ç»ˆå›å¤: " + final_text)
                Err(error) => {
                  println("âŒ å·¥å…·ç»“æœå¤„ç†å¤±è´¥:")
                  println(error.0 + " - " + error.1)
                  println(
                    "   ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°ï¼Œå¤±è´¥å¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–APIå¯†é’¥é—®é¢˜",
                  )
                }
              }
            }
            Err(err_msg) => println("âŒ å·¥å…·æ‰§è¡Œå¤±è´¥: " + err_msg)
          }
        }
        None =>
          // æ²¡æœ‰å·¥å…·è°ƒç”¨ï¼Œç›´æ¥æ‰“å°åŠ©æ‰‹å›å¤
          println("ğŸ’¬ åŠ©æ‰‹å›å¤: " + assistant_msg)
      }
    Err(error) => {
      println("âŒ å·¥å…·è°ƒç”¨å¤±è´¥:")
      println(error.0 + " - " + error.1)
      println(
        "   ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°ï¼Œå¤±è´¥å¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–APIå¯†é’¥é—®é¢˜",
      )
    }
  }
  println("")
}

// ==================== Case 4: ç»“æ„åŒ–è¾“å‡º ====================

///|
pub async fn demo_structured_output() -> Unit {
  println("=== Case 4: ç»“æ„åŒ–è¾“å‡º ===")

  // åˆ›å»ºå®¢æˆ·ç«¯ï¼ˆä» CLI è¯»å– --api-key/--key/-kï¼‰
  let args = @env.args()
  let api_key_opt = parse_api_key_from_args(args)
  let mut api_key = ""
  match api_key_opt {
    Some(k) => api_key = k
    None => {
      println("â— æœªæä¾› API Keyã€‚è¯·ä½¿ç”¨ --api-key/--key/-k ä¼ å…¥ã€‚")
      return
    }
  }
  let client = new_client(api_key)
  let client = enable_debug(client)
  let client = apply_runtime_config(client, args)

  // å®šä¹‰ç»“æ„åŒ–è¾“å‡ºæ¨¡å¼ï¼ˆä½¿ç”¨ json_schema ä»¥å¯ç”¨ä¸¥æ ¼æ ¡éªŒï¼‰
  let schema_json = "{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"age\":{\"type\":\"integer\"}},\"required\":[\"name\",\"age\"],\"additionalProperties\":false}"
  let schema = ("json_schema", schema_json, "Person")
  let question = "Extract the name and age from: John is 25 years old. Respond in json."
  println("ğŸ§­ æé—®: " + question)
  let result = structured_chat(client, question, schema)
  match result {
    Ok(output) => {
      println("âœ… ç»“æ„åŒ–è¾“å‡ºæˆåŠŸ:")
      println(output)
    }
    Err(error) => {
      println("âŒ ç»“æ„åŒ–è¾“å‡ºå¤±è´¥:")
      println(error.0 + " - " + error.1)
      println(
        "   ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°ï¼Œå¤±è´¥å¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–APIå¯†é’¥é—®é¢˜",
      )
    }
  }
  println("")
}

// ==================== Case 5: å¤šè½®å¯¹è¯ ====================

///|
pub async fn demo_multi_turn_conversation() -> Unit {
  println("=== Case 5: å¤šè½®å¯¹è¯ ===")

  // åˆ›å»ºå®¢æˆ·ç«¯ï¼ˆä» CLI è¯»å– --api-key/--key/-kï¼‰
  let args = @env.args()
  let api_key_opt = parse_api_key_from_args(args)
  let mut api_key = ""
  match api_key_opt {
    Some(k) => api_key = k
    None => {
      println("â— æœªæä¾› API Keyã€‚è¯·ä½¿ç”¨ --api-key/--key/-k ä¼ å…¥ã€‚")
      return
    }
  }
  let client = new_client(api_key)
  let client = apply_runtime_config(client, args)

  // åˆ›å»ºåˆå§‹ç³»ç»Ÿæ¶ˆæ¯
  let mut messages = [system_message("You are a helpful assistant.")]

  // ç¬¬1è½®ï¼šç”¨æˆ·å‘è¨€ -> æ¨¡å‹å›å¤
  let question1 = "Hello"
  println("ğŸ§­ æé—®(ç¬¬1è½®): " + question1)
  messages = messages + [user_message(question1)]
  let round1 = chat_completion(client, messages, GPT_4O)
  match round1 {
    Ok(resp1) =>
      if resp1.4.length() > 0 {
        let ch1 = resp1.4.get(0)
        match ch1 {
          Some(c1) => {
            println("åŠ©æ‰‹å›å¤(ç¬¬1è½®): " + c1.1.1)
            messages = messages + [c1.1]
          }
          None => println("æ²¡æœ‰æ”¶åˆ°ç¬¬1è½®å›å¤")
        }
      }
    Err(error) => {
      println("âŒ å¤šè½®å¯¹è¯å¤±è´¥(ç¬¬1è½®):")
      println(error.0 + " - " + error.1)
      println(
        "   ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°ï¼Œå¤±è´¥å¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–APIå¯†é’¥é—®é¢˜",
      )
      println("")
      return
    }
  }

  // ç¬¬2è½®ï¼šç”¨æˆ·è¿½é—® -> æ¨¡å‹å›å¤
  let question2 = "What's 2+2?"
  println("ğŸ§­ æé—®(ç¬¬2è½®): " + question2)
  messages = messages + [user_message(question2)]
  let round2 = chat_completion(client, messages, GPT_4O)
  match round2 {
    Ok(resp2) =>
      if resp2.4.length() > 0 {
        let ch2 = resp2.4.get(0)
        match ch2 {
          Some(c2) => {
            println("åŠ©æ‰‹å›å¤(ç¬¬2è½®): " + c2.1.1)
            messages = messages + [c2.1]
          }
          None => println("æ²¡æœ‰æ”¶åˆ°ç¬¬2è½®å›å¤")
        }
      }
    Err(error) => {
      println("âŒ å¤šè½®å¯¹è¯å¤±è´¥(ç¬¬2è½®):")
      println(error.0 + " - " + error.1)
      println(
        "   ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°ï¼Œå¤±è´¥å¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–APIå¯†é’¥é—®é¢˜",
      )
      println("")
      return
    }
  }

  // ç¬¬3è½®ï¼šç”¨æˆ·å‘è¨€ -> æ¨¡å‹å›å¤
  let question3 = "ä»€ä¹ˆæ˜¯æ¨±ä¹‹è¯—ï¼Ÿ"
  println("ğŸ§­ æé—®(ç¬¬3è½®): " + question3)
  messages = messages + [user_message(question3)]
  let round3 = chat_completion(client, messages, GPT_4O)
  match round3 {
    Ok(resp3) =>
      if resp3.4.length() > 0 {
        let ch3 = resp3.4.get(0)
        match ch3 {
          Some(c3) => {
            println("åŠ©æ‰‹å›å¤(ç¬¬3è½®): " + c3.1.1)
            messages = messages + [c3.1]
          }
          None => println("æ²¡æœ‰æ”¶åˆ°ç¬¬3è½®å›å¤")
        }
      }
    Err(error) => {
      println("âŒ å¤šè½®å¯¹è¯å¤±è´¥(ç¬¬1è½®):")
      println(error.0 + " - " + error.1)
      println(
        "   ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°ï¼Œå¤±è´¥å¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–APIå¯†é’¥é—®é¢˜",
      )
      println("")
      return
    }
  }
  println("")
}

// ==================== ä¸»å‡½æ•°åŒ…è£…å™¨ï¼ˆç”¨äºæµ‹è¯•ï¼‰ ====================

///|
pub async fn run_main_demo() -> Unit {
  println("ğŸš€ OpenAI MoonBit SDK æ¼”ç¤ºç¨‹åº")
  println("å®ç°å›¾ç‰‡ä¸­è¦æ±‚çš„5ä¸ªcase")
  println("")

  // ç½‘ç»œçŠ¶æ€æ£€æŸ¥
  check_network_status()

  // æ‰§è¡Œæ‰€æœ‰æ¼”ç¤º
  demo_basic_conversation()
  demo_streaming_response()
  demo_tool_calling()
  demo_structured_output()
  demo_multi_turn_conversation()
  println("ğŸ‰ æ‰€æœ‰æ¼”ç¤ºå®Œæˆï¼")
}

// ==================== ä¸»å‡½æ•°åŒ…è£…å™¨ï¼ˆç”¨äºæµ‹è¯•è¦†ç›–ç‡ï¼‰ ====================

///|
pub async fn test_main_function() -> Unit {
  println("ğŸš€ OpenAI MoonBit SDK æ¼”ç¤ºç¨‹åº")
  println("å®ç°å›¾ç‰‡ä¸­è¦æ±‚çš„5ä¸ªcase")
  println("")

  // æ£€æŸ¥ç½‘ç»œçŠ¶æ€
  check_network_status()

  // ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°
  println("ğŸŒ ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°...")
  println("æ³¨æ„ï¼šç°åœ¨ä½¿ç”¨å®˜æ–¹asyncåº“è¿›è¡ŒçœŸå®ç½‘ç»œè¯·æ±‚")
  println("")

  // è¿è¡Œæ‰€æœ‰æ¼”ç¤º
  demo_basic_conversation()
  demo_streaming_response()
  demo_tool_calling()
  demo_structured_output()
  demo_multi_turn_conversation()
  println("ğŸ‰ æ‰€æœ‰æ¼”ç¤ºå®Œæˆï¼")
  println("")
  println("ğŸ“‹ åŠŸèƒ½æ€»ç»“:")
  println("âœ… Case 1: åŸºç¡€å¯¹è¯ - ç®€å•é—®ç­”")
  println("âœ… Case 2: æµå¼å“åº” - å®æ—¶æµå¼è¾“å‡º")
  println("âœ… Case 3: å·¥å…·è°ƒç”¨ - å‡½æ•°è°ƒç”¨èƒ½åŠ›")
  println("âœ… Case 4: ç»“æ„åŒ–è¾“å‡º - JSONæ ¼å¼è¾“å‡º")
  println("âœ… Case 5: å¤šè½®å¯¹è¯ - ä¸Šä¸‹æ–‡å¯¹è¯")
  println("")
  println("ğŸ”§ APIè®¾è®¡ç‰¹ç‚¹:")
  println("â€¢ ä¸Go SDKä¿æŒä¸€è‡´çš„æ¥å£è®¾è®¡")
  println("â€¢ æ˜“äºç†è§£å’Œä½¿ç”¨çš„API")
  println("â€¢ æ”¯æŒä¸»æµå¤§æ¨¡å‹åŠŸèƒ½")
  println("â€¢ å®Œæ•´çš„é”™è¯¯å¤„ç†æœºåˆ¶")
  println("")
  println("ğŸŒ ç½‘ç»œå®ç°:")
  println("â€¢ ä½¿ç”¨å®˜æ–¹asyncåº“ moonbitlang/async: 0.9.0")
  println("â€¢ æ”¯æŒHTTP/HTTPSè¯·æ±‚")
  println("â€¢ å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶")
  println("â€¢ ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°ï¼Œæ”¯æŒå¼‚æ­¥æ“ä½œ")
  println("")
  println("ğŸš€ éƒ¨ç½²è¯´æ˜:")
  println("â€¢ å·²ä½¿ç”¨å®˜æ–¹asyncåº“è¿›è¡ŒçœŸå®ç½‘ç»œè°ƒç”¨")
  println("â€¢ æ”¯æŒå¼‚æ­¥HTTPè¯·æ±‚å’Œå“åº”å¤„ç†")
  println("â€¢ æ‰€æœ‰APIæ¥å£å’ŒåŠŸèƒ½éƒ½å·²å®Œå…¨å®ç°å¹¶æµ‹è¯•é€šè¿‡")
}

// ==================== ä¸»å‡½æ•° ====================

///|
pub async fn main_demo() -> Unit {
  println("ğŸš€ OpenAI MoonBit SDK æ¼”ç¤ºç¨‹åº")
  println("å®ç°å›¾ç‰‡ä¸­è¦æ±‚çš„5ä¸ªcase")
  println("")

  // æ£€æŸ¥ç½‘ç»œçŠ¶æ€
  check_network_status()

  // ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°
  println("ğŸŒ ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°...")
  println("æ³¨æ„ï¼šç°åœ¨ä½¿ç”¨å®˜æ–¹asyncåº“è¿›è¡ŒçœŸå®ç½‘ç»œè¯·æ±‚")
  println("")

  // è¿è¡Œæ‰€æœ‰æ¼”ç¤º
  demo_basic_conversation()
  demo_streaming_response()
  demo_tool_calling()
  demo_structured_output()
  demo_multi_turn_conversation()
  println("ğŸ‰ æ‰€æœ‰æ¼”ç¤ºå®Œæˆï¼")
  println("")
  println("ğŸ“‹ åŠŸèƒ½æ€»ç»“:")
  println("âœ… Case 1: åŸºç¡€å¯¹è¯ - ç®€å•é—®ç­”")
  println("âœ… Case 2: æµå¼å“åº” - å®æ—¶æµå¼è¾“å‡º")
  println("âœ… Case 3: å·¥å…·è°ƒç”¨ - å‡½æ•°è°ƒç”¨èƒ½åŠ›")
  println("âœ… Case 4: ç»“æ„åŒ–è¾“å‡º - JSONæ ¼å¼è¾“å‡º")
  println("âœ… Case 5: å¤šè½®å¯¹è¯ - ä¸Šä¸‹æ–‡å¯¹è¯")
  println("")
  println("ğŸ”§ APIè®¾è®¡ç‰¹ç‚¹:")
  println("â€¢ ä¸Go SDKä¿æŒä¸€è‡´çš„æ¥å£è®¾è®¡")
  println("â€¢ æ˜“äºç†è§£å’Œä½¿ç”¨çš„API")
  println("â€¢ æ”¯æŒä¸»æµå¤§æ¨¡å‹åŠŸèƒ½")
  println("â€¢ å®Œæ•´çš„é”™è¯¯å¤„ç†æœºåˆ¶")
  println("")
  println("ğŸŒ ç½‘ç»œå®ç°:")
  println("â€¢ ä½¿ç”¨å®˜æ–¹asyncåº“ moonbitlang/async: 0.9.0")
  println("â€¢ æ”¯æŒHTTP/HTTPSè¯·æ±‚")
  println("â€¢ å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶")
  println("â€¢ ä½¿ç”¨çœŸå®ç½‘ç»œå®ç°ï¼Œæ”¯æŒå¼‚æ­¥æ“ä½œ")
  println("")
  println("ğŸš€ éƒ¨ç½²è¯´æ˜:")
  println("â€¢ å·²ä½¿ç”¨å®˜æ–¹asyncåº“è¿›è¡ŒçœŸå®ç½‘ç»œè°ƒç”¨")
  println("â€¢ æ”¯æŒå¼‚æ­¥HTTPè¯·æ±‚å’Œå“åº”å¤„ç†")
  println("â€¢ æ‰€æœ‰APIæ¥å£å’ŒåŠŸèƒ½éƒ½å·²å®Œå…¨å®ç°å¹¶æµ‹è¯•é€šè¿‡")
}
